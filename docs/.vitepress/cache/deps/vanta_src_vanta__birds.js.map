{
  "version": 3,
  "sources": ["../../../../node_modules/vanta/vendor/GPUComputationRenderer.js", "../../../../node_modules/vanta/src/vanta.birds.js"],
  "sourcesContent": ["const win = typeof window == 'object'\r\nlet THREE = win && window.THREE\r\nlet {\r\n\tCamera,\r\n\tClampToEdgeWrapping,\r\n\tDataTexture,\r\n\tFloatType,\r\n\tMesh,\r\n\tNearestFilter,\r\n\tPlaneBufferGeometry,\r\n\tRGBAFormat,\r\n\tScene,\r\n\tShaderMaterial,\r\n\tWebGLRenderTarget\r\n} = (THREE || {})\r\n\r\n/**\r\n * GPUComputationRenderer, based on SimulationRenderer by zz85\r\n *\r\n * The GPUComputationRenderer uses the concept of variables. These variables are RGBA float textures that hold 4 floats\r\n * for each compute element (texel)\r\n *\r\n * Each variable has a fragment shader that defines the computation made to obtain the variable in question.\r\n * You can use as many variables you need, and make dependencies so you can use textures of other variables in the shader\r\n * (the sampler uniforms are added automatically) Most of the variables will need themselves as dependency.\r\n *\r\n * The renderer has actually two render targets per variable, to make ping-pong. Textures from the current frame are used\r\n * as inputs to render the textures of the next frame.\r\n *\r\n * The render targets of the variables can be used as input textures for your visualization shaders.\r\n *\r\n * Variable names should be valid identifiers and should not collide with THREE GLSL used identifiers.\r\n * a common approach could be to use 'texture' prefixing the variable name; i.e texturePosition, textureVelocity...\r\n *\r\n * The size of the computation (sizeX * sizeY) is defined as 'resolution' automatically in the shader. For example:\r\n * #DEFINE resolution vec2( 1024.0, 1024.0 )\r\n *\r\n * -------------\r\n *\r\n * Basic use:\r\n *\r\n * // Initialization...\r\n *\r\n * // Create computation renderer\r\n * var gpuCompute = new GPUComputationRenderer( 1024, 1024, renderer );\r\n *\r\n * // Create initial state float textures\r\n * var pos0 = gpuCompute.createTexture();\r\n * var vel0 = gpuCompute.createTexture();\r\n * // and fill in here the texture data...\r\n *\r\n * // Add texture variables\r\n * var velVar = gpuCompute.addVariable( \"textureVelocity\", fragmentShaderVel, pos0 );\r\n * var posVar = gpuCompute.addVariable( \"texturePosition\", fragmentShaderPos, vel0 );\r\n *\r\n * // Add variable dependencies\r\n * gpuCompute.setVariableDependencies( velVar, [ velVar, posVar ] );\r\n * gpuCompute.setVariableDependencies( posVar, [ velVar, posVar ] );\r\n *\r\n * // Add custom uniforms\r\n * velVar.material.uniforms.time = { value: 0.0 };\r\n *\r\n * // Check for completeness\r\n * var error = gpuCompute.init();\r\n * if ( error !== null ) {\r\n *\t\tconsole.error( error );\r\n  * }\r\n *\r\n *\r\n * // In each frame...\r\n *\r\n * // Compute!\r\n * gpuCompute.compute();\r\n *\r\n * // Update texture uniforms in your visualization materials with the gpu renderer output\r\n * myMaterial.uniforms.myTexture.value = gpuCompute.getCurrentRenderTarget( posVar ).texture;\r\n *\r\n * // Do your rendering\r\n * renderer.render( myScene, myCamera );\r\n *\r\n * -------------\r\n *\r\n * Also, you can use utility functions to create ShaderMaterial and perform computations (rendering between textures)\r\n * Note that the shaders can have multiple input textures.\r\n *\r\n * var myFilter1 = gpuCompute.createShaderMaterial( myFilterFragmentShader1, { theTexture: { value: null } } );\r\n * var myFilter2 = gpuCompute.createShaderMaterial( myFilterFragmentShader2, { theTexture: { value: null } } );\r\n *\r\n * var inputTexture = gpuCompute.createTexture();\r\n *\r\n * // Fill in here inputTexture...\r\n *\r\n * myFilter1.uniforms.theTexture.value = inputTexture;\r\n *\r\n * var myRenderTarget = gpuCompute.createRenderTarget();\r\n * myFilter2.uniforms.theTexture.value = myRenderTarget.texture;\r\n *\r\n * var outputRenderTarget = gpuCompute.createRenderTarget();\r\n *\r\n * // Now use the output texture where you want:\r\n * myMaterial.uniforms.map.value = outputRenderTarget.texture;\r\n *\r\n * // And compute each frame, before rendering to screen:\r\n * gpuCompute.doRenderTarget( myFilter1, myRenderTarget );\r\n * gpuCompute.doRenderTarget( myFilter2, outputRenderTarget );\r\n *\r\n *\r\n *\r\n * @param {int} sizeX Computation problem size is always 2d: sizeX * sizeY elements.\r\n * @param {int} sizeY Computation problem size is always 2d: sizeX * sizeY elements.\r\n * @param {WebGLRenderer} renderer The renderer\r\n  */\r\n\r\nvar GPUComputationRenderer = function ( sizeX, sizeY, renderer, userTHREE) {\r\n\tif (userTHREE) {\r\n\t\t({ Camera,\r\n\t\t\tClampToEdgeWrapping,\r\n\t\t\tDataTexture,\r\n\t\t\tFloatType,\r\n\t\t\tMesh,\r\n\t\t\tNearestFilter,\r\n\t\t\tPlaneBufferGeometry,\r\n\t\t\tRGBAFormat,\r\n\t\t\tScene,\r\n\t\t\tShaderMaterial,\r\n\t\t\tWebGLRenderTarget} = userTHREE)\r\n\t}\r\n\r\n\r\n\tthis.variables = [];\r\n\r\n\tthis.currentTextureIndex = 0;\r\n\r\n\tvar dataType = FloatType;\r\n\r\n\tvar scene = new Scene();\r\n\r\n\tvar camera = new Camera();\r\n\tcamera.position.z = 1;\r\n\r\n\tvar passThruUniforms = {\r\n\t\tpassThruTexture: { value: null }\r\n\t};\r\n\r\n\tvar passThruShader = createShaderMaterial( getPassThroughFragmentShader(), passThruUniforms );\r\n\r\n\tvar mesh = new Mesh( new PlaneBufferGeometry( 2, 2 ), passThruShader );\r\n\tscene.add( mesh );\r\n\r\n\r\n\tthis.setDataType = function ( type ) {\r\n\r\n\t\tdataType = type;\r\n\t\treturn this;\r\n\r\n\t};\r\n\r\n\tthis.addVariable = function ( variableName, computeFragmentShader, initialValueTexture ) {\r\n\r\n\t\tvar material = this.createShaderMaterial( computeFragmentShader );\r\n\r\n\t\tvar variable = {\r\n\t\t\tname: variableName,\r\n\t\t\tinitialValueTexture: initialValueTexture,\r\n\t\t\tmaterial: material,\r\n\t\t\tdependencies: null,\r\n\t\t\trenderTargets: [],\r\n\t\t\twrapS: null,\r\n\t\t\twrapT: null,\r\n\t\t\tminFilter: NearestFilter,\r\n\t\t\tmagFilter: NearestFilter\r\n\t\t};\r\n\r\n\t\tthis.variables.push( variable );\r\n\r\n\t\treturn variable;\r\n\r\n\t};\r\n\r\n\tthis.setVariableDependencies = function ( variable, dependencies ) {\r\n\r\n\t\tvariable.dependencies = dependencies;\r\n\r\n\t};\r\n\r\n\tthis.init = function () {\r\n\r\n\t\tif ( ! renderer.capabilities.isWebGL2 &&\r\n\t\t\t ! renderer.extensions.get( \"OES_texture_float\" ) ) {\r\n\r\n\t\t\treturn \"No OES_texture_float support for float textures.\";\r\n\r\n\t\t}\r\n\r\n\t\tif ( renderer.capabilities.maxVertexTextures === 0 ) {\r\n\r\n\t\t\treturn \"No support for vertex shader textures.\";\r\n\r\n\t\t}\r\n\r\n\t\tfor ( var i = 0; i < this.variables.length; i ++ ) {\r\n\r\n\t\t\tvar variable = this.variables[ i ];\r\n\r\n\t\t\t// Creates rendertargets and initialize them with input texture\r\n\t\t\tvariable.renderTargets[ 0 ] = this.createRenderTarget( sizeX, sizeY, variable.wrapS, variable.wrapT, variable.minFilter, variable.magFilter );\r\n\t\t\tvariable.renderTargets[ 1 ] = this.createRenderTarget( sizeX, sizeY, variable.wrapS, variable.wrapT, variable.minFilter, variable.magFilter );\r\n\t\t\tthis.renderTexture( variable.initialValueTexture, variable.renderTargets[ 0 ] );\r\n\t\t\tthis.renderTexture( variable.initialValueTexture, variable.renderTargets[ 1 ] );\r\n\r\n\t\t\t// Adds dependencies uniforms to the ShaderMaterial\r\n\t\t\tvar material = variable.material;\r\n\t\t\tvar uniforms = material.uniforms;\r\n\r\n\t\t\tif ( variable.dependencies !== null ) {\r\n\r\n\t\t\t\tfor ( var d = 0; d < variable.dependencies.length; d ++ ) {\r\n\r\n\t\t\t\t\tvar depVar = variable.dependencies[ d ];\r\n\r\n\t\t\t\t\tif ( depVar.name !== variable.name ) {\r\n\r\n\t\t\t\t\t\t// Checks if variable exists\r\n\t\t\t\t\t\tvar found = false;\r\n\t\t\t\t\t\tfor ( var j = 0; j < this.variables.length; j ++ ) {\r\n\r\n\t\t\t\t\t\t\tif ( depVar.name === this.variables[ j ].name ) {\r\n\r\n\t\t\t\t\t\t\t\tfound = true;\r\n\t\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tif ( ! found ) {\r\n\r\n\t\t\t\t\t\t\treturn \"Variable dependency not found. Variable=\" + variable.name + \", dependency=\" + depVar.name;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tuniforms[ depVar.name ] = { value: null };\r\n\r\n\t\t\t\t\tmaterial.fragmentShader = \"\\nuniform sampler2D \" + depVar.name + \";\\n\" + material.fragmentShader;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tthis.currentTextureIndex = 0;\r\n\r\n\t\treturn null;\r\n\r\n\t};\r\n\r\n\tthis.compute = function () {\r\n\r\n\t\tvar currentTextureIndex = this.currentTextureIndex;\r\n\t\tvar nextTextureIndex = this.currentTextureIndex === 0 ? 1 : 0;\r\n\r\n\t\tfor ( var i = 0, il = this.variables.length; i < il; i ++ ) {\r\n\r\n\t\t\tvar variable = this.variables[ i ];\r\n\r\n\t\t\t// Sets texture dependencies uniforms\r\n\t\t\tif ( variable.dependencies !== null ) {\r\n\r\n\t\t\t\tvar uniforms = variable.material.uniforms;\r\n\t\t\t\tfor ( var d = 0, dl = variable.dependencies.length; d < dl; d ++ ) {\r\n\r\n\t\t\t\t\tvar depVar = variable.dependencies[ d ];\r\n\r\n\t\t\t\t\tuniforms[ depVar.name ].value = depVar.renderTargets[ currentTextureIndex ].texture;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// Performs the computation for this variable\r\n\t\t\tthis.doRenderTarget( variable.material, variable.renderTargets[ nextTextureIndex ] );\r\n\r\n\t\t}\r\n\r\n\t\tthis.currentTextureIndex = nextTextureIndex;\r\n\r\n\t};\r\n\r\n\tthis.getCurrentRenderTarget = function ( variable ) {\r\n\r\n\t\treturn variable.renderTargets[ this.currentTextureIndex ];\r\n\r\n\t};\r\n\r\n\tthis.getAlternateRenderTarget = function ( variable ) {\r\n\r\n\t\treturn variable.renderTargets[ this.currentTextureIndex === 0 ? 1 : 0 ];\r\n\r\n\t};\r\n\r\n\tfunction addResolutionDefine( materialShader ) {\r\n\r\n\t\tmaterialShader.defines.resolution = 'vec2( ' + sizeX.toFixed( 1 ) + ', ' + sizeY.toFixed( 1 ) + \" )\";\r\n\r\n\t}\r\n\r\n\tthis.addResolutionDefine = addResolutionDefine;\r\n\r\n\r\n\t// The following functions can be used to compute things manually\r\n\r\n\tfunction createShaderMaterial( computeFragmentShader, uniforms ) {\r\n\r\n\t\tuniforms = uniforms || {};\r\n\r\n\t\tvar material = new ShaderMaterial( {\r\n\t\t\tuniforms: uniforms,\r\n\t\t\tvertexShader: getPassThroughVertexShader(),\r\n\t\t\tfragmentShader: computeFragmentShader\r\n\t\t} );\r\n\r\n\t\taddResolutionDefine( material );\r\n\r\n\t\treturn material;\r\n\r\n\t}\r\n\r\n\tthis.createShaderMaterial = createShaderMaterial;\r\n\r\n\tthis.createRenderTarget = function ( sizeXTexture, sizeYTexture, wrapS, wrapT, minFilter, magFilter ) {\r\n\r\n\t\tsizeXTexture = sizeXTexture || sizeX;\r\n\t\tsizeYTexture = sizeYTexture || sizeY;\r\n\r\n\t\twrapS = wrapS || ClampToEdgeWrapping;\r\n\t\twrapT = wrapT || ClampToEdgeWrapping;\r\n\r\n\t\tminFilter = minFilter || NearestFilter;\r\n\t\tmagFilter = magFilter || NearestFilter;\r\n\r\n\t\tvar renderTarget = new WebGLRenderTarget( sizeXTexture, sizeYTexture, {\r\n\t\t\twrapS: wrapS,\r\n\t\t\twrapT: wrapT,\r\n\t\t\tminFilter: minFilter,\r\n\t\t\tmagFilter: magFilter,\r\n\t\t\tformat: RGBAFormat,\r\n\t\t\ttype: dataType,\r\n\t\t\tstencilBuffer: false,\r\n\t\t\tdepthBuffer: false\r\n\t\t} );\r\n\r\n\t\treturn renderTarget;\r\n\r\n\t};\r\n\r\n\tthis.createTexture = function () {\r\n\r\n\t\tvar data = new Float32Array( sizeX * sizeY * 4 );\r\n\t\treturn new DataTexture( data, sizeX, sizeY, RGBAFormat, FloatType );\r\n\r\n\t};\r\n\r\n\tthis.renderTexture = function ( input, output ) {\r\n\r\n\t\t// Takes a texture, and render out in rendertarget\r\n\t\t// input = Texture\r\n\t\t// output = RenderTarget\r\n\r\n\t\tpassThruUniforms.passThruTexture.value = input;\r\n\r\n\t\tthis.doRenderTarget( passThruShader, output );\r\n\r\n\t\tpassThruUniforms.passThruTexture.value = null;\r\n\r\n\t};\r\n\r\n\tthis.doRenderTarget = function ( material, output ) {\r\n\r\n\t\tvar currentRenderTarget = renderer.getRenderTarget();\r\n\r\n\t\tmesh.material = material;\r\n\t\trenderer.setRenderTarget( output );\r\n\t\trenderer.render( scene, camera );\r\n\t\tmesh.material = passThruShader;\r\n\r\n\t\trenderer.setRenderTarget( currentRenderTarget );\r\n\r\n\t};\r\n\r\n\t// Shaders\r\n\r\n\tfunction getPassThroughVertexShader() {\r\n\r\n\t\treturn\t\"void main()\t{\\n\" +\r\n\t\t\t\t\"\\n\" +\r\n\t\t\t\t\"\tgl_Position = vec4( position, 1.0 );\\n\" +\r\n\t\t\t\t\"\\n\" +\r\n\t\t\t\t\"}\\n\";\r\n\r\n\t}\r\n\r\n\tfunction getPassThroughFragmentShader() {\r\n\r\n\t\treturn\t\"uniform sampler2D passThruTexture;\\n\" +\r\n\t\t\t\t\"\\n\" +\r\n\t\t\t\t\"void main() {\\n\" +\r\n\t\t\t\t\"\\n\" +\r\n\t\t\t\t\"\tvec2 uv = gl_FragCoord.xy / resolution.xy;\\n\" +\r\n\t\t\t\t\"\\n\" +\r\n\t\t\t\t\"\tgl_FragColor = texture2D( passThruTexture, uv );\\n\" +\r\n\t\t\t\t\"\\n\" +\r\n\t\t\t\t\"}\\n\";\r\n\r\n\t}\r\n\r\n};\r\n\r\nexport default  GPUComputationRenderer;\r\n", "// Adapted from https://threejs.org/examples/canvas_geometry_birds.html\r\n\r\nimport VantaBase, { VANTA } from './_base.js'\r\n// import {rn, ri, sample} from './helpers.js'\r\nimport {mobileCheck} from './helpers.js'\r\nimport GPUComputationRenderer from '../vendor/GPUComputationRenderer.js'\r\n\r\nconst win = typeof window == 'object'\r\nlet THREE = win && window.THREE\r\nconst GPGPU = !mobileCheck()\r\n\r\nlet WIDTH = 32\r\nlet BIRDS = WIDTH * WIDTH\r\nconst BOUNDS = 800\r\nconst BOUNDS_HALF = BOUNDS / 2\r\n\r\n\r\nconst getNewBirdGeometry = (options) => {\r\n  const scope = new THREE.BufferGeometry()\r\n\r\n  if (options.quantity) {\r\n    WIDTH = Math.pow(2, options.quantity)\r\n    BIRDS = WIDTH * WIDTH\r\n  }\r\n  const triangles = BIRDS * 3\r\n  const points = triangles * 3\r\n\r\n  const vertices = new THREE.BufferAttribute(new Float32Array(points * 3), 3)\r\n  const birdColors = new THREE.BufferAttribute(new Float32Array(points * 3), 3)\r\n  const references = new THREE.BufferAttribute(new Float32Array(points * 2), 2)\r\n  const birdVertex = new THREE.BufferAttribute(new Float32Array(points), 1)\r\n\r\n  if (!scope.setAttribute) scope.setAttribute = scope.addAttribute // handle three.js migration r109 â†’ r110\r\n  scope.setAttribute('position', vertices)\r\n  scope.setAttribute('birdColor', birdColors)\r\n  scope.setAttribute('reference', references)\r\n  scope.setAttribute('birdVertex', birdVertex)\r\n  // scope.addAttribute( 'normal', new Float32Array( points * 3 ), 3 )\r\n\r\n  let v = 0\r\n  const verts_push = function() {\r\n    for (let i=0; i<arguments.length; i++) {\r\n      vertices.array[v++] = arguments[i]\r\n    }\r\n  }\r\n\r\n  const wingSpan = options.wingSpan || 20\r\n  const s = options.birdSize || 1\r\n\r\n  for (let f=0; f<BIRDS; f++) {\r\n    verts_push(0, -0, -20*s, 0, 4*s, -20*s, 0, 0, 30*s) // Body\r\n    verts_push(0, 0, -15*s, -wingSpan*s, 0, 0, 0, 0, 15*s) // Left Wing\r\n    verts_push(0, 0, 15*s, wingSpan*s, 0, 0, 0, 0, -15*s) // Right Wing\r\n  }\r\n\r\n  const colorCache = {}\r\n\r\n  for (v=0; v<triangles*3; v++) {\r\n    const i = ~~(v / 3)\r\n    const x = (i % WIDTH) / WIDTH\r\n    const y = ~~(i / WIDTH) / WIDTH\r\n    const order = ~~(v / 9) / BIRDS\r\n    const key = order.toString()\r\n    const gradient = options.colorMode.indexOf('Gradient') != -1\r\n    let c\r\n    if (!gradient && colorCache[key]) {\r\n      c = colorCache[key]\r\n    } else {\r\n      c = options.effect.getNewCol(order)\r\n    }\r\n    if (!gradient && !colorCache[key]) {\r\n      colorCache[key] = c\r\n    }\r\n\r\n    birdColors.array[(v * 3) + 0] = c.r\r\n    birdColors.array[(v * 3) + 1] = c.g\r\n    birdColors.array[(v * 3) + 2] = c.b\r\n    references.array[v * 2] = x\r\n    references.array[(v * 2) + 1] = y\r\n    birdVertex.array[v] = v % 9\r\n  }\r\n  return scope.scale(0.2, 0.2, 0.2)\r\n}\r\n\r\nconst getNewBirdGeometryBasic = (options={}) => {\r\n  const scope = new THREE.BufferGeometry()\r\n  const points = []\r\n  function v( x, y, z ) {\r\n    const s = 1.5 * (options.birdSize || 1)\r\n    points.push( new THREE.Vector3( x*s, y*s, z*s ) )\r\n  }\r\n  v(   5,   0,   0 )\r\n  v( - 5, - 1,   1 )\r\n  v( - 5,   0,   0 )\r\n  v( - 5, - 2, - 1 )\r\n  v(   0,   2, - 6 )\r\n  v(   0,   2,   6 )\r\n  v(   2,   0,   0 )\r\n  v( - 3,   0,   0 )\r\n  scope.setFromPoints(points)\r\n\r\n  const indices = []\r\n  indices.push( 0, 2, 1 )\r\n  // f3( 0, 3, 2 )\r\n  indices.push( 4, 7, 6 )\r\n  indices.push( 5, 6, 7 )\r\n  scope.setIndex(indices)\r\n\r\n  // this.computeCentroids()\r\n  return scope\r\n}\r\n\r\n// Based on http://www.openprocessing.org/visuals/?visualID=6910\r\nclass Boid {\r\n  constructor (options) {\r\n    var vector = new THREE.Vector3(),\r\n    _acceleration,\r\n    _width = 500,\r\n    _height = 500,\r\n    _depth = 200, _goal,\r\n    _neighborhoodRadius = 100,\r\n    _maxSpeed = 2.5,\r\n    _maxSteerForce = 0.1,\r\n    _avoidWalls = true;\r\n\r\n    var _options = options\r\n\r\n    this.position = new THREE.Vector3()\r\n    this.velocity = new THREE.Vector3()\r\n    _acceleration = new THREE.Vector3()\r\n\r\n    this.setGoal = function ( target ) {\r\n      _goal = target;\r\n    }\r\n\r\n    // this.setAvoidWalls = function ( value ) {\r\n    //   _avoidWalls = value;\r\n    // }\r\n\r\n    this.setWorldSize = function ( width, height, depth ) {\r\n      _width = width;\r\n      _height = height;vector\r\n      _depth = depth;\r\n    }\r\n\r\n    this.run = function ( boids ) {\r\n      if ( _avoidWalls ) {\r\n        vector.set( - _width, this.position.y, this.position.z )\r\n        vector = this.avoid( vector )\r\n        vector.multiplyScalar( 5 )\r\n        _acceleration.add( vector )\r\n\r\n        vector.set( _width, this.position.y, this.position.z )\r\n        vector = this.avoid( vector )\r\n        vector.multiplyScalar( 5 )\r\n        _acceleration.add( vector )\r\n\r\n        vector.set( this.position.x, - _height, this.position.z )\r\n        vector = this.avoid( vector )\r\n        vector.multiplyScalar( 5 )\r\n        _acceleration.add( vector )\r\n\r\n        vector.set( this.position.x, _height, this.position.z )\r\n        vector = this.avoid( vector )\r\n        vector.multiplyScalar( 5 )\r\n        _acceleration.add( vector )\r\n\r\n        vector.set( this.position.x, this.position.y, - _depth )\r\n        vector = this.avoid( vector )\r\n        vector.multiplyScalar( 5 )\r\n        _acceleration.add( vector )\r\n\r\n        vector.set( this.position.x, this.position.y, _depth )\r\n        vector = this.avoid( vector )\r\n        vector.multiplyScalar( 5 )\r\n        _acceleration.add( vector )\r\n      }/* else {\r\n        this.checkBounds();\r\n      }*/\r\n\r\n      if ( Math.random() > 0.5 ) {\r\n        this.flock( boids )\r\n      }\r\n      this.move()\r\n    }\r\n\r\n    this.flock = function ( boids ) {\r\n      if ( _goal ) {\r\n        _acceleration.add( this.reach( _goal, 0.005 ) )\r\n      }\r\n      _acceleration.add( this.alignment( boids ) )\r\n      _acceleration.add( this.cohesion( boids ) )\r\n      _acceleration.add( this.separation( boids ) )\r\n    }\r\n\r\n    this.move = function () {\r\n      this.velocity.add( _acceleration )\r\n      var l = this.velocity.length()\r\n      if ( l > _maxSpeed ) {\r\n        this.velocity.divideScalar( l / _maxSpeed )\r\n      }\r\n      this.position.add( this.velocity )\r\n      _acceleration.set( 0, 0, 0 )\r\n    }\r\n\r\n    this.checkBounds = function () {\r\n      if ( this.position.x >   _width ) this.position.x = - _width;\r\n      if ( this.position.x < - _width ) this.position.x =   _width;\r\n      if ( this.position.y >   _height ) this.position.y = - _height;\r\n      if ( this.position.y < - _height ) this.position.y =  _height;\r\n      if ( this.position.z >  _depth ) this.position.z = - _depth;\r\n      if ( this.position.z < - _depth ) this.position.z =  _depth;\r\n    }\r\n\r\n    this.avoid = function ( target ) {\r\n      var steer = new THREE.Vector3()\r\n      steer.copy( this.position )\r\n      steer.sub( target )\r\n      steer.multiplyScalar( 1 / this.position.distanceToSquared( target ) )\r\n      return steer\r\n    }\r\n\r\n    this.repulse = function ( target ) {\r\n      var distance = this.position.distanceTo( target )\r\n      if ( distance < 150 ) {\r\n        var steer = new THREE.Vector3()\r\n        steer.subVectors( this.position, target )\r\n        steer.multiplyScalar( 0.5 / distance )\r\n        _acceleration.add( steer )\r\n      }\r\n    }\r\n\r\n    this.reach = function ( target, amount ) {\r\n      var steer = new THREE.Vector3()\r\n      steer.subVectors( target, this.position )\r\n      steer.multiplyScalar( amount )\r\n      return steer\r\n    }\r\n\r\n    this.alignment = function ( boids ) {\r\n      var boid, velSum = new THREE.Vector3(), count = 0, distance\r\n      const radius = _neighborhoodRadius * _options.alignment/20\r\n      for ( var i = 0, il = boids.length; i < il; i++ ) {\r\n        if ( Math.random() > 0.6 ) continue\r\n        boid = boids[ i ]\r\n        distance = boid.position.distanceTo( this.position )\r\n        if ( distance > 0 && distance <= radius ) {\r\n          velSum.add( boid.velocity )\r\n          count++\r\n        }\r\n      }\r\n      if ( count > 0 ) {\r\n        velSum.divideScalar( count )\r\n        var l = velSum.length()\r\n        if ( l > _maxSteerForce ) {\r\n          velSum.divideScalar( l / _maxSteerForce )\r\n        }\r\n      }\r\n      return velSum\r\n    }\r\n\r\n    this.cohesion = function ( boids ) {\r\n      var boid, distance,\r\n      posSum = new THREE.Vector3(),\r\n      steer = new THREE.Vector3(),\r\n      count = 0\r\n      const radius = _neighborhoodRadius * _options.cohesion/20\r\n\r\n      for ( var i = 0, il = boids.length; i < il; i ++ ) {\r\n        if ( Math.random() > 0.6 ) continue\r\n        boid = boids[ i ]\r\n        distance = boid.position.distanceTo( this.position )\r\n\r\n        if ( distance > 0 && distance <= radius ) {\r\n          posSum.add( boid.position )\r\n          count++\r\n        }\r\n      }\r\n      if ( count > 0 ) {\r\n        posSum.divideScalar( count )\r\n      }\r\n      steer.subVectors( posSum, this.position )\r\n      var l = steer.length()\r\n      if ( l > _maxSteerForce ) {\r\n        steer.divideScalar( l / _maxSteerForce )\r\n      }\r\n      return steer\r\n    }\r\n\r\n    this.separation = function ( boids ) {\r\n      var boid, distance,\r\n        posSum = new THREE.Vector3(),\r\n        repulse = new THREE.Vector3()\r\n      const radius = _neighborhoodRadius * _options.separation/20\r\n\r\n      for ( var i = 0, il = boids.length; i < il; i ++ ) {\r\n        if ( Math.random() > 0.6 ) continue\r\n        boid = boids[ i ]\r\n        distance = boid.position.distanceTo( this.position )\r\n        if ( distance > 0 && distance <= radius ) {\r\n          repulse.subVectors( this.position, boid.position )\r\n          repulse.normalize()\r\n          repulse.divideScalar( distance )\r\n          posSum.add( repulse )\r\n        }\r\n      }\r\n      return posSum\r\n    }\r\n  }\r\n}\r\n\r\n\r\n\r\nconst fragmentShaderPosition = `\\\r\nuniform float time;\r\nuniform float delta;\r\n\r\nvoid main() {\r\n\r\n  vec2 uv = gl_FragCoord.xy / resolution.xy;\r\n  vec4 tmpPos = texture2D( texturePosition, uv );\r\n  vec3 position = tmpPos.xyz;\r\n  vec3 velocity = texture2D( textureVelocity, uv ).xyz;\r\n\r\n  float phase = tmpPos.w;\r\n\r\n  phase = mod( ( phase + delta +\r\n    length( velocity.xz ) * delta * 3. +\r\n    max( velocity.y, 0.0 ) * delta * 6. ), 62.83 );\r\n\r\n  gl_FragColor = vec4( position + velocity * delta * 15. , phase );\r\n\r\n}`\r\n\r\nconst fragmentShaderVelocity = `\\\r\nuniform float time;\r\nuniform float testing;\r\nuniform float delta; // about 0.016\r\nuniform float separationDistance; // 20\r\nuniform float alignmentDistance; // 40\r\nuniform float cohesionDistance;\r\nuniform float speedLimit;\r\nuniform float freedomFactor;\r\nuniform vec3 predator;\r\n\r\nconst float width = resolution.x;\r\nconst float height = resolution.y;\r\n\r\nconst float PI = 3.141592653589793;\r\nconst float PI_2 = PI * 2.0;\r\n// const float VISION = PI * 0.55;\r\n\r\nfloat zoneRadius = 40.0;\r\nfloat zoneRadiusSquared = 1600.0;\r\n\r\nfloat separationThresh = 0.45;\r\nfloat alignmentThresh = 0.65;\r\n\r\nconst float UPPER_BOUNDS = BOUNDS;\r\nconst float LOWER_BOUNDS = -UPPER_BOUNDS;\r\n\r\nfloat rand(vec2 co){\r\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\r\n}\r\n\r\nvoid main() {\r\n\r\n  zoneRadius = separationDistance + alignmentDistance + cohesionDistance;\r\n  separationThresh = separationDistance / zoneRadius;\r\n  alignmentThresh = ( separationDistance + alignmentDistance ) / zoneRadius;\r\n  zoneRadiusSquared = zoneRadius * zoneRadius;\r\n\r\n\r\n  vec2 uv = gl_FragCoord.xy / resolution.xy;\r\n  vec3 birdPosition, birdVelocity;\r\n\r\n  vec3 selfPosition = texture2D( texturePosition, uv ).xyz;\r\n  vec3 selfVelocity = texture2D( textureVelocity, uv ).xyz;\r\n\r\n  float dist;\r\n  vec3 dir; // direction\r\n  float distSquared;\r\n\r\n  float separationSquared = separationDistance * separationDistance;\r\n  float cohesionSquared = cohesionDistance * cohesionDistance;\r\n\r\n  float f;\r\n  float percent;\r\n\r\n  vec3 velocity = selfVelocity;\r\n\r\n  float limit = speedLimit;\r\n\r\n  dir = predator * UPPER_BOUNDS - selfPosition;\r\n  dir.z = 0.;\r\n  // dir.z *= 0.6;\r\n  dist = length( dir );\r\n  distSquared = dist * dist;\r\n\r\n  float preyRadius = 150.0;\r\n  float preyRadiusSq = preyRadius * preyRadius;\r\n\r\n  // move birds away from predator\r\n  if (dist < preyRadius) {\r\n\r\n    f = ( distSquared / preyRadiusSq - 1.0 ) * delta * 100.;\r\n    velocity += normalize( dir ) * f;\r\n    limit += 5.0;\r\n  }\r\n\r\n  // if (testing == 0.0) {}\r\n  // if ( rand( uv + time ) < freedomFactor ) {}\r\n\r\n  // Attract flocks to the center\r\n  vec3 central = vec3( 0., 0., 0. );\r\n  dir = selfPosition - central;\r\n  dist = length( dir );\r\n\r\n  dir.y *= 2.5;\r\n  velocity -= normalize( dir ) * delta * 5.;\r\n\r\n  for (float y=0.0;y<height;y++) {\r\n    for (float x=0.0;x<width;x++) {\r\n\r\n      vec2 ref = vec2( x + 0.5, y + 0.5 ) / resolution.xy;\r\n      birdPosition = texture2D( texturePosition, ref ).xyz;\r\n\r\n      dir = birdPosition - selfPosition;\r\n      dist = length(dir);\r\n\r\n      if (dist < 0.0001) continue;\r\n\r\n      distSquared = dist * dist;\r\n\r\n      if (distSquared > zoneRadiusSquared ) continue;\r\n\r\n      percent = distSquared / zoneRadiusSquared;\r\n\r\n      if ( percent < separationThresh ) { // low\r\n\r\n        // Separation - Move apart for comfort\r\n        f = (separationThresh / percent - 1.0) * delta;\r\n        velocity -= normalize(dir) * f;\r\n\r\n      } else if ( percent < alignmentThresh ) { // high\r\n\r\n        // Alignment - fly the same direction\r\n        float threshDelta = alignmentThresh - separationThresh;\r\n        float adjustedPercent = ( percent - separationThresh ) / threshDelta;\r\n\r\n        birdVelocity = texture2D( textureVelocity, ref ).xyz;\r\n\r\n        f = ( 0.5 - cos( adjustedPercent * PI_2 ) * 0.5 + 0.5 ) * delta;\r\n        velocity += normalize(birdVelocity) * f;\r\n\r\n      } else {\r\n\r\n        // Attraction / Cohesion - move closer\r\n        float threshDelta = 1.0 - alignmentThresh;\r\n        float adjustedPercent = ( percent - alignmentThresh ) / threshDelta;\r\n\r\n        f = ( 0.5 - ( cos( adjustedPercent * PI_2 ) * -0.5 + 0.5 ) ) * delta;\r\n\r\n        velocity += normalize(dir) * f;\r\n\r\n      }\r\n    }\r\n  }\r\n\r\n  // this make tends to fly around than down or up\r\n  // if (velocity.y > 0.) velocity.y *= (1. - 0.2 * delta);\r\n\r\n  // Speed Limits\r\n  if ( length( velocity ) > limit ) {\r\n    velocity = normalize( velocity ) * limit;\r\n  }\r\n\r\n  gl_FragColor = vec4( velocity, 1.0 );\r\n\r\n}`\r\n\r\nconst birdVS = `\\\r\nattribute vec2 reference;\r\nattribute float birdVertex;\r\n\r\nattribute vec3 birdColor;\r\n\r\nuniform sampler2D texturePosition;\r\nuniform sampler2D textureVelocity;\r\n\r\nvarying vec4 vColor;\r\nvarying float z;\r\n\r\nuniform float time;\r\nuniform float birdSize;\r\n\r\nvoid main() {\r\n\r\n  vec4 tmpPos = texture2D( texturePosition, reference );\r\n  vec3 pos = tmpPos.xyz;\r\n  vec3 velocity = normalize(texture2D( textureVelocity, reference ).xyz);\r\n\r\n  vec3 newPosition = position;\r\n\r\n  if ( birdVertex == 4.0 || birdVertex == 7.0 ) {\r\n    // flap wings\r\n    newPosition.y = sin( tmpPos.w ) * 5. * birdSize;\r\n  }\r\n\r\n  newPosition = mat3( modelMatrix ) * newPosition;\r\n\r\n  velocity.z *= -1.;\r\n  float xz = length( velocity.xz );\r\n  float xyz = 1.;\r\n  float x = sqrt( 1. - velocity.y * velocity.y );\r\n\r\n  float cosry = velocity.x / xz;\r\n  float sinry = velocity.z / xz;\r\n\r\n  float cosrz = x / xyz;\r\n  float sinrz = velocity.y / xyz;\r\n\r\n  mat3 maty =  mat3(\r\n    cosry, 0, -sinry,\r\n    0    , 1, 0     ,\r\n    sinry, 0, cosry\r\n  );\r\n\r\n  mat3 matz =  mat3(\r\n    cosrz , sinrz, 0,\r\n    -sinrz, cosrz, 0,\r\n    0     , 0    , 1\r\n  );\r\n  newPosition =  maty * matz * newPosition;\r\n  newPosition += pos;\r\n  z = newPosition.z;\r\n\r\n  vColor = vec4( birdColor, 1.0 );\r\n  gl_Position = projectionMatrix *  viewMatrix  * vec4( newPosition, 1.0 );\r\n}`\r\n\r\nconst birdFS = `\\\r\nvarying vec4 vColor;\r\nvarying float z;\r\nuniform vec3 color;\r\nvoid main() {\r\n  // Fake colors for now\r\n  float rr = 0.2 + ( 1000. - z ) / 1000. * vColor.x;\r\n  float gg = 0.2 + ( 1000. - z ) / 1000. * vColor.y;\r\n  float bb = 0.2 + ( 1000. - z ) / 1000. * vColor.z;\r\n  gl_FragColor = vec4( rr, gg, bb, 1. );\r\n}`\r\n\r\nconst fillPositionTexture = function(texture) {\r\n  const theArray = texture.image.data\r\n  let k = 0\r\n  const kl = theArray.length\r\n  return (() => {\r\n    const result = []\r\n    while (k < kl) {\r\n      const x = (Math.random() * BOUNDS) - BOUNDS_HALF\r\n      const y = (Math.random() * BOUNDS) - BOUNDS_HALF\r\n      const z = (Math.random() * BOUNDS) - BOUNDS_HALF\r\n      theArray[k + 0] = x\r\n      theArray[k + 1] = y\r\n      theArray[k + 2] = z\r\n      theArray[k + 3] = 1\r\n      result.push(k += 4)\r\n    }\r\n    return result\r\n  })()\r\n}\r\n\r\nconst fillVelocityTexture = function(texture) {\r\n  const theArray = texture.image.data\r\n  let k = 0\r\n  const kl = theArray.length\r\n  return (() => {\r\n    const result = []\r\n    while (k < kl) {\r\n      const x = Math.random() - 0.5\r\n      const y = Math.random() - 0.5\r\n      const z = Math.random() - 0.5\r\n      theArray[k + 0] = x * 10\r\n      theArray[k + 1] = y * 10\r\n      theArray[k + 2] = z * 10\r\n      theArray[k + 3] = 1\r\n      result.push(k += 4)\r\n    }\r\n    return result\r\n  })()\r\n}\r\n\r\nclass Birds extends VantaBase {\r\n  static initClass() {\r\n    this.prototype.defaultOptions = {\r\n      // Beige: 0xf8e8d0, 0xf50000, 0xcfcf1d\r\n      backgroundColor: 0x07192F, // 0x202428\r\n      color1: 0xff0000, // 0xf50000 # 0xfa9898\r\n      color2: 0x00d1ff, // 0xcfcf1d # 0x8c4646\r\n      colorMode: 'varianceGradient',\r\n      birdSize: 1,\r\n      wingSpan: 30,\r\n      speedLimit: 5,\r\n      separation: 20,\r\n      alignment: 20,\r\n      cohesion: 20,\r\n      quantity: 5, // range from 2 to 5\r\n    }\r\n  }\r\n\r\n  constructor(userOptions) {\r\n    THREE = userOptions.THREE || THREE\r\n    super(userOptions)\r\n  }\r\n\r\n  initComputeRenderer() {\r\n    this.gpuCompute = new GPUComputationRenderer(WIDTH, WIDTH, this.renderer, THREE)\r\n    const dtPosition = this.gpuCompute.createTexture()\r\n    const dtVelocity = this.gpuCompute.createTexture()\r\n    fillPositionTexture(dtPosition)\r\n    fillVelocityTexture(dtVelocity)\r\n    this.velocityVariable = this.gpuCompute.addVariable('textureVelocity', fragmentShaderVelocity, dtVelocity)\r\n    this.positionVariable = this.gpuCompute.addVariable('texturePosition', fragmentShaderPosition, dtPosition)\r\n    this.gpuCompute.setVariableDependencies(this.velocityVariable, [\r\n      this.positionVariable,\r\n      this.velocityVariable\r\n    ])\r\n    this.gpuCompute.setVariableDependencies(this.positionVariable, [\r\n      this.positionVariable,\r\n      this.velocityVariable\r\n    ])\r\n    this.positionUniforms = this.positionVariable.material.uniforms\r\n    this.velocityUniforms = this.velocityVariable.material.uniforms\r\n    this.positionUniforms.time = {value: 0.0}\r\n    this.positionUniforms.delta = {value: 0.0}\r\n    this.velocityUniforms.time = {value: 1.0}\r\n    this.velocityUniforms.delta = {value: 0.0}\r\n    this.velocityUniforms.testing = {value: 1.0}\r\n    this.velocityUniforms.separationDistance = {value: 1.0}\r\n    this.velocityUniforms.alignmentDistance = {value: 1.0}\r\n    this.velocityUniforms.cohesionDistance = {value: 1.0}\r\n    this.velocityUniforms.speedLimit = {value: 1.0}\r\n    this.velocityUniforms.freedomFactor = {value: 1.0}\r\n    this.velocityUniforms.predator = {value: new THREE.Vector3}\r\n    this.velocityVariable.material.defines.BOUNDS = BOUNDS.toFixed(2)\r\n    this.velocityVariable.wrapS = THREE.RepeatWrapping\r\n    this.velocityVariable.wrapT = THREE.RepeatWrapping\r\n    this.positionVariable.wrapS = THREE.RepeatWrapping\r\n    this.positionVariable.wrapT = THREE.RepeatWrapping\r\n    const error = this.gpuCompute.init()\r\n    if (error !== null) {\r\n      console.error(error)\r\n    }\r\n  }\r\n\r\n  initGpgpuBirds() {\r\n    const optionsWithEffect = Object.assign({}, this.options, {effect:this})\r\n    const geometry = getNewBirdGeometry(optionsWithEffect)\r\n    // For Vertex and Fragment\r\n    this.birdUniforms = {\r\n      color: { value: new THREE.Color(0xff2200) },\r\n      texturePosition: { value: null },\r\n      textureVelocity: { value: null },\r\n      time: { value: 1.0 },\r\n      delta: { value: 0.0 },\r\n      birdSize: {value: this.options.birdSize}\r\n    }\r\n    // ShaderMaterial\r\n    const material = new THREE.ShaderMaterial({\r\n      uniforms: this.birdUniforms,\r\n      vertexShader: birdVS,\r\n      fragmentShader: birdFS,\r\n      side: THREE.DoubleSide\r\n    });\r\n    const birdMesh = new THREE.Mesh(geometry, material)\r\n    birdMesh.rotation.y = Math.PI / 2\r\n    birdMesh.matrixAutoUpdate = false\r\n    birdMesh.updateMatrix()\r\n    return this.scene.add(birdMesh)\r\n  }\r\n\r\n  getNewCol(order) {\r\n    const options = this.options\r\n    const color1 = options.color1 != null ? options.color1 : 0x440000\r\n    const color2 = options.color2 != null ? options.color2 : 0x660000\r\n    const c1 = new THREE.Color(color1)\r\n    const c2 = new THREE.Color(color2)\r\n    const gradient = options.colorMode.indexOf('Gradient') != -1\r\n    let c, dist\r\n    if (gradient) {\r\n      // each vertex has a different color\r\n      dist = Math.random()\r\n    } else {\r\n      // each vertex has the same color\r\n      dist = order\r\n    }\r\n\r\n    if (options.colorMode.indexOf('variance') == 0) {\r\n      const r2 = (c1.r + Math.random() * c2.r).clamp(0,1)\r\n      const g2 = (c1.g + Math.random() * c2.g).clamp(0,1)\r\n      const b2 = (c1.b + Math.random() * c2.b).clamp(0,1)\r\n      c = new THREE.Color(r2, g2, b2)\r\n    } else if (options.colorMode.indexOf('mix') == 0) {\r\n      // Naive color arithmetic\r\n      c = new THREE.Color(color1 + dist * color2)\r\n    } else {\r\n      // Linear interpolation\r\n      c = c1.lerp(c2, dist)\r\n    }\r\n    return c\r\n  }\r\n\r\n  onInit() {\r\n    this.camera = new THREE.PerspectiveCamera( 75, this.width / this.height, 1, 3000 )\r\n    this.camera.position.z = 350\r\n    this.fog = new THREE.Fog( 0xffffff, 100, 1000 )\r\n    this.mouseX = (this.mouseY = 0)\r\n\r\n    const birds = this.birds = []\r\n\t\tconst boids = this.boids = []\r\n    const options = this.options\r\n    let boid, bird\r\n\r\n    if (GPGPU) {\r\n      try {\r\n        this.initComputeRenderer()\r\n        this.valuesChanger = this.valuesChanger.bind(this)\r\n        this.valuesChanger()\r\n        this.initGpgpuBirds()\r\n      } catch (err) {\r\n        console.error('[vanta.js] birds init error: ', err)\r\n      }\r\n    } else {\r\n      const numBirds = 6 * Math.pow(2, options.quantity)\r\n      for (var i = 0; i < numBirds; i++) {\r\n        boid = boids[i] = new Boid(options)\r\n        boid.position.x = Math.random() * 400 - 200\r\n        boid.position.y = Math.random() * 400 - 200\r\n        boid.position.z = Math.random() * 400 - 200\r\n        boid.velocity.x = Math.random() * 2 - 1\r\n        boid.velocity.y = Math.random() * 2 - 1\r\n        boid.velocity.z = Math.random() * 2 - 1\r\n        boid.setWorldSize( 500, 500, 300 )\r\n\r\n        const gradient = options.colorMode.indexOf('Gradient') != -1\r\n\r\n        const newBirdGeo = getNewBirdGeometryBasic(options)\r\n        const numV = newBirdGeo.attributes.position.length\r\n        const birdColors = new THREE.BufferAttribute(new Float32Array(numV), 3)\r\n        if (gradient) {\r\n          for (var j=0; j<newBirdGeo.index.array.length; j+=3) {\r\n            for (var k=0; k<=2; k++) {\r\n              const index = newBirdGeo.index.array[j+k]\r\n              const newColor = this.getNewCol()\r\n              birdColors.array[index*3] = newColor.r\r\n              birdColors.array[index*3+1] = newColor.g\r\n              birdColors.array[index*3+2] = newColor.b\r\n            }\r\n          }\r\n        } else {\r\n          const newColor = this.getNewCol(i/numBirds)\r\n          for (var j=0; j<birdColors.array.length; j+=3) {\r\n            birdColors.array[j] = newColor.r\r\n            birdColors.array[j+1] = newColor.g\r\n            birdColors.array[j+2] = newColor.b\r\n          }\r\n        }\r\n        newBirdGeo.setAttribute('color', birdColors)\r\n\r\n        bird = birds[i] = new THREE.Mesh(\r\n          newBirdGeo,\r\n          new THREE.MeshBasicMaterial( {\r\n            color: 0xffffff,\r\n            side: THREE.DoubleSide,\r\n            // colors: THREE.VertexColors,\r\n\t\t\t\t\t  vertexColors: THREE.VertexColors,\r\n          }))\r\n        bird.phase = Math.floor( Math.random() * 62.83 )\r\n        bird.position.x = boids[i].position.x\r\n        bird.position.y = boids[i].position.y\r\n        bird.position.z = boids[i].position.z\r\n        this.scene.add( bird )\r\n        // if (i == 0) {\r\n        //   window.bird = bird; window.boid = boid;\r\n        // }\r\n      }\r\n    }\r\n  }\r\n\r\n  valuesChanger() {\r\n    if (this.velocityUniforms) {\r\n      this.velocityUniforms.separationDistance.value = this.options.separation\r\n      this.velocityUniforms.alignmentDistance.value = this.options.alignment\r\n      this.velocityUniforms.speedLimit.value = this.options.speedLimit\r\n      this.velocityUniforms.cohesionDistance.value = this.options.cohesion\r\n    }\r\n  }\r\n\r\n  onUpdate() {\r\n    this.now = performance.now()\r\n    if (!this.last) { this.last = this.now }\r\n    let delta = (this.now - this.last) / 1000\r\n\r\n    if (delta > 1) { delta = 1 }\r\n    this.last = this.now\r\n\r\n    if (GPGPU) {\r\n      this.positionUniforms.time.value = this.now\r\n      this.positionUniforms.delta.value = delta\r\n      this.velocityUniforms.time.value = this.now\r\n      this.velocityUniforms.delta.value = delta\r\n      this.birdUniforms.time.value = this.now\r\n      this.birdUniforms.delta.value = delta\r\n      this.velocityUniforms.predator.value.set(\r\n        this.mouseX,\r\n        -this.mouseY,\r\n        0\r\n      )\r\n      this.mouseX = 10000\r\n      this.mouseY = 10000\r\n      this.gpuCompute.compute()\r\n      this.birdUniforms.texturePosition.value = this.gpuCompute.getCurrentRenderTarget( this.positionVariable ).texture\r\n      this.birdUniforms.textureVelocity.value = this.gpuCompute.getCurrentRenderTarget( this.velocityVariable ).texture\r\n    } else {\r\n      const birds = this.birds\r\n      const boids = this.boids\r\n      let boid, bird, color\r\n      for ( var i = 0, il = birds.length; i < il; i++ ) {\r\n        boid = boids[i]\r\n        boid.run( boids )\r\n        bird = birds[i]\r\n        // color = bird.material.color\r\n        // color.r = color.g = color.b = ( 500 - bird.position.z ) / 1000\r\n        bird.rotation.y = Math.atan2( - boid.velocity.z, boid.velocity.x )\r\n        bird.rotation.z = Math.asin( boid.velocity.y / boid.velocity.length() )\r\n        // Flapping\r\n        bird.phase = (bird.phase + (Math.max(0, bird.rotation.z)+0.1)) % 62.83\r\n\r\n        const tip1 = 5*3 + 1\r\n        const tip2 = 4*3 + 1\r\n        bird.geometry.attributes.position.array[tip1] = bird.geometry.attributes.position.array[tip2] =\r\n          Math.sin( bird.phase ) * 5 * this.options.birdSize\r\n        bird.geometry.attributes.position.needsUpdate = true\r\n        bird.geometry.computeVertexNormals()\r\n\r\n        bird.position.x = boids[i].position.x\r\n        bird.position.y = boids[i].position.y\r\n        bird.position.z = boids[i].position.z\r\n      }\r\n    }\r\n  }\r\n  onMouseMove(x,y) {\r\n    // Center on 0,0\r\n    this.mouseX = x - 0.5\r\n    this.mouseY = y - 0.5\r\n    if (!GPGPU) {\r\n      const boids = this.boids\r\n      let boid\r\n      var vector = new THREE.Vector3( this.mouseX * this.width, -this.mouseY * this.height, 0 );\r\n      for ( var i = 0, il = boids.length; i < il; i++ ) {\r\n        boid = boids[i]\r\n        vector.z = boid.position.z\r\n        boid.repulse( vector )\r\n\t\t\t}\r\n    }\r\n  }\r\n  onDestroy() {}\r\n  onResize() {}\r\n}\r\nBirds.initClass()\r\nexport default VANTA.register('BIRDS', Birds)"],
  "mappings": "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",
  "names": ["win", "THREE"]
}
